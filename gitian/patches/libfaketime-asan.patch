diff --git a/libsanitizer/asan/asan_linux.cc b/libsanitizer/asan/asan_linux.cc
index c504168..1d1a6dd 100644
--- a/libsanitizer/asan/asan_linux.cc
+++ b/libsanitizer/asan/asan_linux.cc
@@ -112,7 +112,10 @@ void AsanCheckDynamicRTPrereqs() {
     Report("ASan runtime does not come first in initial library list; "
            "you should either link runtime to your application or "
            "manually preload it with LD_PRELOAD.\n");
-    Die();
+    // Don't die here. We are preloading libfaketime as we need it for
+    // reproducible builds which makes it always the first DSO. Thus, dying here
+    // breaks the build for us.
+    // Die();
   }
 }
 
diff --git a/libsanitizer/sanitizer_common/SelfRandoAddressTranslator.h b/libsanitizer/sanitizer_common/SelfRandoAddressTranslator.h
new file mode 100644
index 0000000..5f13870
--- /dev/null
+++ b/libsanitizer/sanitizer_common/SelfRandoAddressTranslator.h
@@ -0,0 +1,155 @@
+//
+// Created by tf on 10/12/2015.
+//
+
+#pragma once
+#include "sanitizer_internal_defs.h"
+#include "sanitizer_libc.h"
+#include "sanitizer_common.h"
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+
+namespace __sanitizer {
+    class SelfRandoAddressTranslator {
+        struct __attribute__((__packed__)) FunctionRecord {
+            void *undiv_addr;
+            void *div_addr;
+            u32 size;
+        };
+
+        struct __attribute__((__packed__)) LibraryRecord {
+            u32 version;
+            u32 seed;
+            void *file_base;
+            void *mem_base;
+            void *size;
+
+        private:
+            char _name;
+
+        public:
+            inline char *name() { return &_name; }
+
+            inline FunctionRecord *function_records() {
+                return (FunctionRecord *) (&_name + internal_strlen(&_name) + 1);
+            }
+
+            u8 *record_end() {
+                FunctionRecord *fr = function_records();
+                while (fr->undiv_addr) {
+                    fr++;
+                }
+                return (u8 *) fr + sizeof(void *);
+            }
+        };
+
+        // 16K loaded modules should be enough for everyone.
+        LibraryRecord* library_records_idx[1<<14];
+        int library_records_idx_size;
+        u8 *library_records_end;
+        void add_library_record(LibraryRecord* lr);
+
+        void read_layout_file();
+        u8 *record_end(int i);
+
+    public:
+        SelfRandoAddressTranslator();
+
+        uptr convertAddress(uptr original_address);
+    };
+
+
+
+
+    SelfRandoAddressTranslator::SelfRandoAddressTranslator() {
+        Printf("SRAT init\n");
+        read_layout_file();
+    }
+
+    void SelfRandoAddressTranslator::add_library_record(LibraryRecord* lr) {
+        library_records_idx_size++;
+        CHECK(library_records_idx_size <= 1<<14);
+        library_records_idx[library_records_idx_size - 1] = lr;
+    }
+
+    u8* SelfRandoAddressTranslator::record_end(int i) {
+        if (i < library_records_idx_size - 1) {
+            return (u8 *) library_records_idx[i + 1] - sizeof(void *);
+        } else {
+            return library_records_end - sizeof(void*);
+        }
+    }
+
+    void SelfRandoAddressTranslator::read_layout_file() {
+        uptr pid = internal_getpid();
+        char filename[32];
+        internal_snprintf(filename, 32, "/tmp/%d.mlf", pid);
+
+        u8 buf[200]; // Current size of struct stat: 144
+        if(0 != internal_stat(filename, &buf)) {
+            Printf("SRAT warning: cannot find Memory Layout File. Stack trace will be probably wrong.\n");
+            return;
+        }
+
+        uptr fd = OpenFile(filename, /*write*/ false);
+        uptr size = *(uptr*) (buf+48);
+        CHECK_NE(fd, -1);
+        u8 *f = (u8 *) internal_mmap(0, size, PROT_READ, MAP_SHARED, (int) fd, 0);
+        CHECK_NE(f, 0);
+        library_records_end = f + size;
+
+        u8 *p = f;
+        while (p < library_records_end) {
+            LibraryRecord *lr = (LibraryRecord *) p;
+            add_library_record(lr);
+            CHECK_EQ(lr->version, 0x00000101);
+            p = lr->record_end();
+        }
+
+    }
+
+    uptr SelfRandoAddressTranslator::convertAddress(uptr p) {
+//        Printf("conv %p", p);
+        for (int i = 0; i < library_records_idx_size; ++i) {
+            LibraryRecord *lr = library_records_idx[i];
+
+            if (p > (uptr) lr->mem_base && p < (uptr) lr->mem_base + (uptr) lr->size) {
+                // found the correct library
+
+                FunctionRecord *function_records = lr->function_records();
+
+                int a = 0;
+                int b = (int) ((FunctionRecord *) record_end(i) - function_records);
+//                Printf(" (lib=>%s< a=%d b=%d)", lr->name(), a, b);
+                CHECK_EQ((u8 *) (function_records + b), record_end(i));
+
+                while (b - a > 1) { // bisection
+                    int c = a + (b - a) / 2;
+                    FunctionRecord *fr = &function_records[c];
+
+                    if ((uptr) fr->div_addr > p) { // too high
+                        b = c;
+                    } else if ((uptr) fr->div_addr + (uptr) fr->size < p) { // too low
+                        a = c;
+                    } else { // found
+                        b = c + 1;
+                        a = c;
+                    }
+                }
+                FunctionRecord *fr = &function_records[a];
+                CHECK((uptr) fr->div_addr < p && p < (uptr) fr->div_addr + (uptr) fr->size);
+
+                p = (p - (uptr) fr->div_addr + (uptr) fr->undiv_addr);
+
+                break;
+            }
+        }
+
+//        Printf(" => %p\n", p);
+        return p;
+    }
+}
\ No newline at end of file
diff --git a/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
index 5cc21d3..393a494 100644
--- a/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc
@@ -21,6 +21,7 @@
 #include "sanitizer_procmaps.h"
 #include "sanitizer_symbolizer.h"
 #include "sanitizer_symbolizer_libbacktrace.h"
+#include "SelfRandoAddressTranslator.h"
 
 #include <errno.h>
 #include <stdlib.h>
@@ -512,7 +513,7 @@ class POSIXSymbolizer : public Symbolizer {
         internal_symbolizer_(internal_symbolizer),
         libbacktrace_symbolizer_(libbacktrace_symbolizer) {}
 
-  uptr SymbolizePC(uptr addr, AddressInfo *frames, uptr max_frames) {
+  virtual uptr SymbolizePC(uptr addr, AddressInfo *frames, uptr max_frames) {
     BlockingMutexLock l(&mu_);
     if (max_frames == 0)
       return 0;
@@ -580,7 +581,7 @@ class POSIXSymbolizer : public Symbolizer {
     return frame_id;
   }
 
-  bool SymbolizeData(uptr addr, DataInfo *info) {
+  virtual bool SymbolizeData(uptr addr, DataInfo *info) {
     BlockingMutexLock l(&mu_);
     LoadedModule *module = FindModuleForAddress(addr);
     if (module == 0)
@@ -606,7 +607,7 @@ class POSIXSymbolizer : public Symbolizer {
     return true;
   }
 
-  bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,
+  virtual bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,
                                    uptr *module_address) {
     BlockingMutexLock l(&mu_);
     return FindModuleNameAndOffsetForAddress(pc, module_name, module_address);
@@ -720,9 +721,40 @@ class POSIXSymbolizer : public Symbolizer {
   LibbacktraceSymbolizer *libbacktrace_symbolizer_;   // Leaked.
 };
 
+
+    class SelfRandoPOSIXSymbolizer : public POSIXSymbolizer {
+        SelfRandoAddressTranslator translator;
+
+    public:
+        SelfRandoPOSIXSymbolizer(ExternalSymbolizerInterface *external_symbolizer,
+                                 InternalSymbolizer *internal_symbolizer,
+                                 LibbacktraceSymbolizer *libbacktrace_symbolizer)
+                : POSIXSymbolizer(external_symbolizer, internal_symbolizer, libbacktrace_symbolizer),
+                  translator() { }
+
+
+    private:
+        virtual uptr SymbolizePC(uptr addr, AddressInfo *frames, uptr max_frames) override {
+            uptr conv_addr = translator.convertAddress(addr);
+            uptr res = POSIXSymbolizer::SymbolizePC(conv_addr, frames, max_frames);
+            if (res == 1) frames->address = addr;
+            return res;
+        }
+
+        virtual bool SymbolizeData(uptr addr, DataInfo *info) override {
+            addr = translator.convertAddress(addr);
+            return POSIXSymbolizer::SymbolizeData(addr, info);
+        }
+
+        virtual bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name, uptr *module_address) override {
+            pc = translator.convertAddress(pc);
+            return POSIXSymbolizer::GetModuleNameAndOffsetForPC(pc, module_name, module_address);
+        };
+    };
+
 Symbolizer *Symbolizer::PlatformInit() {
   if (!common_flags()->symbolize) {
-    return new(symbolizer_allocator_) POSIXSymbolizer(0, 0, 0);
+    return new(symbolizer_allocator_) SelfRandoPOSIXSymbolizer(0, 0, 0);
   }
   InternalSymbolizer* internal_symbolizer =
       InternalSymbolizer::get(&symbolizer_allocator_);
@@ -754,10 +786,11 @@ Symbolizer *Symbolizer::PlatformInit() {
     }
   }
 
-  return new(symbolizer_allocator_) POSIXSymbolizer(
+  return new(symbolizer_allocator_) SelfRandoPOSIXSymbolizer(
       external_symbolizer, internal_symbolizer, libbacktrace_symbolizer);
 }
 
+
 }  // namespace __sanitizer
 
 #endif  // SANITIZER_POSIX
